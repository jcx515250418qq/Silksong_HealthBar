# 召唤类敌人相关代码标记总结

本文档标记了游戏源码中与"召唤类"敌人相关的核心代码部分，供研究使用。

## 1. EnemySpawner.cs - 敌人召唤器核心逻辑

**文件位置**: `游戏源码参考/EnemySpawner.cs`

### 🔥 核心召唤逻辑代码段:

#### 1.1 召唤器初始化 (第32-39行)
```csharp
private void Awake()
{
    sprite = GetComponent<tk2dSprite>();
    sprite.color = startColor;
    if ((bool)enemyPrefab)
    {
        spawnedEnemy = UnityEngine.Object.Instantiate(enemyPrefab);  // 🔥 实例化召唤敌人
        spawnedEnemy.SetActive(value: false);  // 🔥 初始状态为禁用
    }
}
```

#### 1.2 召唤概率判断和动画启动 (第41-60行)
```csharp
private void Start()
{
    if (UnityEngine.Random.Range(0f, 1f) <= spawnChance)  // 🔥 召唤概率判断
    {
        // 事件监听和动画设置
        if ((bool)killEvent)
        {
            killEvent.ReceivedEvent += delegate
            {
                base.gameObject.SetActive(value: false);
            };
        }
        // iTween动画配置
        Hashtable hashtable = new Hashtable();
        hashtable.Add("amount", moveBy);
        hashtable.Add("time", easeTime);
        hashtable.Add("easetype", easeType);
        hashtable.Add("space", Space.World);
        iTween.MoveBy(base.gameObject, hashtable);
    }
}
```

#### 1.3 召唤敌人激活逻辑 (第70-96行)
```csharp
private void Update()
{
    // 颜色过渡和时间判断
    elapsed += Time.deltaTime;
    sprite.color = Color.Lerp(startColor, endColor, Mathf.Clamp(elapsed / easeTime, 0f, 1f));
    
    if (elapsed > easeTime)
    {
        isComplete = true;
        spawnedEnemy.transform.position = base.transform.position;  // 🔥 设置召唤敌人位置
        spawnedEnemy.transform.localScale = base.transform.localScale;  // 🔥 设置召唤敌人缩放
        spawnedEnemy.SetActive(value: true);  // 🔥 激活召唤的敌人
        
        if (this.OnEnemySpawned != null)
        {
            this.OnEnemySpawned(spawnedEnemy);  // 🔥 触发敌人召唤事件
        }
        
        // 设置敌人AI状态
        PlayMakerFSM playMakerFSM = PlayMakerFSM.FindFsmOnGameObject(spawnedEnemy, "chaser");
        if ((bool)playMakerFSM)
        {
            playMakerFSM.FsmVariables.FindFsmBool("Start Alert").Value = true;
        }
        
        base.gameObject.SetActive(value: false);  // 🔥 召唤器自身禁用
    }
}
```

### 🔥 关键字段:
- `GameObject enemyPrefab` - 要召唤的敌人预制体
- `GameObject spawnedEnemy` - 已召唤的敌人实例
- `float spawnChance` - 召唤概率 (0-1)
- `event Action<GameObject> OnEnemySpawned` - 敌人召唤完成事件

---

## 2. TrackSpawnedEnemiesAdd.cs - 召唤敌人跟踪系统

**文件位置**: `游戏源码参考/TrackSpawnedEnemiesAdd.cs`

### 🔥 核心跟踪逻辑代码段:

#### 2.1 召唤敌人跟踪入口 (第18-38行)
```csharp
public override void OnEnter()
{
    GameObject safe = Target.GetSafe(this);
    if ((bool)safe && (bool)SpawnedEnemy.Value)
    {
        TrackSpawnedEnemies track = safe.GetComponent<TrackSpawnedEnemies>() ?? safe.AddComponent<TrackSpawnedEnemies>();
        
        if (UsesEnemySpawner.Value)  // 🔥 使用EnemySpawner的情况
        {
            EnemySpawner component = SpawnedEnemy.Value.GetComponent<EnemySpawner>();
            if ((bool)component)
            {
                component.OnEnemySpawned += delegate(GameObject enemy)  // 🔥 订阅召唤事件
                {
                    AddTracked(track, enemy);  // 🔥 添加到跟踪列表
                };
            }
        }
        else
        {
            AddTracked(track, SpawnedEnemy.Value);  // 🔥 直接添加到跟踪
        }
    }
    Finish();
}
```

#### 2.2 添加跟踪目标 (第40-47行)
```csharp
private void AddTracked(TrackSpawnedEnemies tracker, GameObject obj)
{
    HealthManager component = obj.GetComponent<HealthManager>();  // 🔥 获取血量管理器
    if ((bool)component)
    {
        tracker.Add(component);  // 🔥 添加到跟踪器
    }
}
```

### 🔥 关键字段:
- `FsmGameObject SpawnedEnemy` - 被召唤的敌人对象
- `FsmBool UsesEnemySpawner` - 是否使用EnemySpawner

---

## 3. HealthManager.cs - 召唤敌人死亡处理

**文件位置**: `游戏源码参考/HealthManager.cs`

### 🔥 核心死亡处理代码段:

#### 3.1 死亡方法入口 (第1536行)
```csharp
public void Die(float? attackDirection, AttackTypes attackType, NailElements nailElement, GameObject damageSource, bool ignoreEvasion = false, float corpseFlingMultiplier = 1f, bool overrideSpecialDeath = false, bool disallowDropFling = false)
{
    if (isDead || (preventDeathAfterHero && HeroController.instance.cState.dead))
    {
        return;  // 🔥 防止重复死亡
    }
    // ... 死亡处理逻辑
}
```

#### 3.2 死亡事件触发 (第1663行)
```csharp
SendDeathEvent();  // 🔥 发送死亡事件
```

#### 3.3 死亡事件实现 (第1862-1868行)
```csharp
public void SendDeathEvent()
{
    if (this.OnDeath != null)
    {
        this.OnDeath();  // 🔥 触发OnDeath事件 - 血条应该监听此事件
    }
}
```

### 🔥 关键事件:
- `event Action OnDeath` - 死亡事件，血条组件应监听此事件进行清理

---

## 4. PlayerData.cs - 召唤相关游戏数据

**文件位置**: `游戏源码参考/PlayerData.cs`

### 🔥 召唤相关字段:

#### 4.1 乌鸦召唤相关 (第1343-1345行)
```csharp
public string CrowSummonsAppearedScene;  // 🔥 乌鸦召唤出现的场景
public bool OpenedCrowSummonsDoor;       // 🔥 是否打开了乌鸦召唤门
```

#### 4.2 救世主召唤 (第1903行)
```csharp
public bool EncounteredSummonedSaviour;  // 🔥 是否遇到了被召唤的救世主
```

#### 4.3 湖泊法球召唤 (第2392行)
```csharp
public bool summonedLakeOrbs;            // 🔥 是否召唤了湖泊法球
```

---

## 🚨 关键问题分析

### 血条停留问题的根本原因:

1. **EnemySpawner缺少OnDestroy清理**: EnemySpawner被销毁时没有清理召唤的敌人
2. **EnemyHealthBar未监听死亡事件**: 血条组件没有订阅HealthManager的OnDeath事件
3. **召唤敌人生命周期管理不完整**: 缺少召唤敌人死亡时的血条清理逻辑

### 建议的修复方案:

1. 在EnemyHealthBar的Start方法中订阅OnDeath事件
2. 在OnDeath事件处理中立即销毁血条UI
3. 在OnDestroy方法中取消事件订阅

---

## 📝 研究要点

- **召唤流程**: EnemySpawner → 实例化 → 激活 → 触发OnEnemySpawned事件
- **跟踪机制**: TrackSpawnedEnemiesAdd监听OnEnemySpawned并添加到跟踪器
- **死亡处理**: HealthManager.Die() → SendDeathEvent() → OnDeath事件
- **血条问题**: 血条组件未正确监听OnDeath事件导致清理失败

这些代码段构成了完整的召唤类敌人系统，研究时重点关注事件流和生命周期管理。